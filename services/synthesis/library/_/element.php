<?php
/**
* This is the fundamental data class in a Synthesis system. An Element can be atomic, though it may refer to other elements through its reference fields.
*
* All original code.
 * @package Synthesis
 * @author Guy Johnson <Guy@SyntheticWebApps.com>
 * @copyright 2007-2014 Lifetoward LLC
 * @license proprietary
*/
abstract class Element extends Instance
{
	const InputWidth = 4; // allows for Element selectors to render at assumed width = 4
	static $keys = 'id', $sysvals = array('capcel');
	private static $cache = array(); // Stored objects are cached to prevent unnecessary reloads and to ensure that within the session scope a unique handle always refers to a unique object.
	protected $capcel = null; // This keeps track of which instance of Instance ultimately *includes this instance of Element
	use SerializationHelper;
	private static $savedProperties = array(array('recache'),'capcel');

	/**
	* Called as the unserializing method, ensuring our cache includes all Element instances restored via the session.
	*/
	private function recache()
	{
		if ($this->_stored) {
			if (self::$cache[$this->_handle])
				throw new ErrorException("Unserializing a duplicate of a cached object: $this->_handle");
			self::$cache[$this->_handle] = $this;
		}
	}

	/**
	* Use this to obtain a dynamically filled-out Operation specification.
	* If an array is passed for $operation, then our job is to return the simple result of getClassOperation or getOperation based on the args in the array ignoring remaining method parameters.
	* Otherwise, when a context is provided we include a target generated by the passed context for requesting the Operation UI.
	* When generating a target, we override (if present in $args) and pass arguments 'operation' and 'class'. The action argument is treated as the dynamic arg in the target.
	* @param mixed $operation If passed as an array, it's assumed to be an array of args as if requested by the request of a target generated here previously, and all other args will be ignored.
	*	If passed as a string, then it must be any operation specification found in the called class's operations list. If the operation is not found there, we return null.
	* @param Context $c (optional) The rendering context from which to obtain the target rendering. Without this no target is generated and none of the following args are used.
	* @param string $actionArg (optional) The name of the argument to pass containing the operation's action value as its value.
	*	The assumed value is '_action' which would be automatically handled by Action::render().
	*	If you pass null here, then the target produced will not include the action at all, leaving the caller to invoke the new Action internally on its reinvocation.
	* @param mixed[] $args (optional) Any args you'd like passed through in the target. Perhaps initializers or other contextual clues which will be recognized by the targeted Action.
	* @param boolean $accept (optional) If you need data to be posted along with the request, set this to true.
	*	This is most often done in conjunction with an $actionArg value which will be processed by the triggering InputAction, allowing it to save some input data before jumping to the new Action.
	* @return string[] An associative array defining the Operation with key 'target' set to a raw URL, requesting which will invoke the operation.
	*/
	public static function getClassOperation( $operation, Context $c = null, $actionArg = '_action', $args = array(), $accept = false )
	{
		if (is_array($operation)) {
			// In this case we look at this array as args from a request derived from an earlier call to this method or the instance-based equivalent to get a target.
			// Our goal is to simply return a finished operation specification array.
			extract($operation, EXTR_OVERWRITE);
			if (!is_subclass_of($class, 'Element'))
				return null;
			return $id ? $class::get($id)->getOperation($operation) : $class::getClassOperation($operation);
		}

		static $standard = array(
			// Create facilitates obtaining via UI the data necessary to produce a new instance from scratch
			 'create'=>array('icon'=>'plus', 'noun'=>'singular', 'verb'=>"Add new", 'action'=>'a_Edit', 'tone'=>'primary')
			// List enables obtaining identifying and possibly a bit more information about the instances of the class
			,'list'=>array('icon'=>'list', 'noun'=>'plural', 'verb'=>"Work with", 'action'=>'a_Browse', 'tone'=>'default')
		);
		if (!isset(static::$operations) || !is_array(static::$operations) || !is_array(static::$operations[$operation]))
			return logWarn("Operation '$operation' not defined for class '". get_called_class() ."'.", null);
		$opspec = static::getOpSpec($operation, $standard);
		if ($c instanceof Context)
			$opspec['target'] = $c->target(array_merge($args, array('operation'=>$operation, 'class'=>get_called_class())), $accept, $actionArg, $actionArg ? $opspec['action'] : null);
		return $opspec;
	}

	/**
	* Use this to obtain a dynamically filled-out Operation specification which includes a target generated by the passed context.
	* We override (if present in $args) and pass arguments 'operation', 'class', and 'id'. The id argument is treated as the dynamic arg in the target.
	* @param string $operation Any operation specification found in the called class's operations list. If the operation is not found there, we return null.
	* @param Context $c (optional) The rendering context from which to obtain the target rendering. Without this no target is generated and none of the following args are used.
	* @param string $actionArg (optional) The name of the argument to pass containing the operation's action value as its value.
	*	The assumed value is '_action' which would be automatically handled by Action::render() as a new subaction.
	*	If you pass null here, then the target produced will not include the action at all, leaving the caller to invoke the new Action internally on its reinvocation.
	* @param mixed[] $args (optional) Any args you'd like passed through in the target. Perhaps initializers or other contextual clues which will be recognized by the targeted Action.
	* @param boolean $accept (optional) If you need data to be posted along with the request, set this to true.
	*	This is most often done in conjunction with an $actionArg value which will be processed by the triggering InputAction, allowing it to save some input data before jumping to the new Action.
	* @return string[] An associative array defining the Operation with key 'target' set to a raw URL, requesting which will invoke the operation.
	*/
	public function getOperation( $operation, Context $c = null, $actionArg = '_action', $args = array(), $accept = false )
	{
		static $standard = array(
			// Display focuses on the instance and renders it with all its available related data.
			 'display'=>array('icon'=>'zoom-in', 'noun'=>'descriptive', 'verb'=>"Display", 'action'=>'a_Display', 'tone'=>'success')
			// Update allows one to change the data of the instance.
			,'update'=>array('icon'=>'edit', 'noun'=>'descriptive', 'verb'=>"Update", 'action'=>'a_Edit', 'tone'=>'warning')
			// Delete removes the instance from the database.
			,'delete'=>array('icon'=>'remove', 'noun'=>'plural', 'verb'=>"Delete", 'action'=>'a_Delete', 'tone'=>'danger')
			// Promote takes an existing instance and instantiates an additional heir. This is one way it can come to be that multiple instances can share the same root instance.
			// ,'promote'=>array('icon'=>'leaf', 'noun'=>'singular', 'verb'=>"Promote")
		);
		if (!$this->key) // operations make no sense against unstored Elements... we couldn't hope to address them with a target
			return null;
		if (!($opspec = static::getOpSpec($operation, $standard))) // this sets args, operation, label, and icon
			return null; // certain conditions will cause the operation fetch to fail... that's OK here, just return null as failure.

		if (is_string($opspec['target'])) { // If opspec['target'] is already specified as a string, it's a the name of a different handler script
			// We assemble the passed args, our operation- and instance-specifying args, and the opspec's args into the query string
			$args = array_merge($args, $opspec['args'], $this->asArgs());
			foreach ($args as $arg=>$val)
				$argpairs[] = urlencode($arg) .'='. urlencode($val);
			$opspec['target'] = "$c->urlbase/$opspec[target]?". implode('&', $argpairs);

		} else if ($c instanceof Context) {
			if ($actionArg)
				$args[$actionArg] = $opspec['action'];
			$args = array_merge($args, $opspec['args'], array('class'=>get_class($this)));
			$opspec['target'] = $c->target($args, $accept, 'id', $this->key);
		}
		return $opspec;
	}

	/**
	* The point of this method is to simply uncache an object. You are on your honor to then forget any other references to it so it can be garbage collected.
	* Only call this for objects you know aren't worth using for the remainder of the request.
	*/
	public function free()
	{
		unset(self::$cache[$this->_handle]);
	}

	/**
	* We expose the create() method of Instance because creating an Element is totally legal from anywhere, unlike some other kinds of instances.
	*/
	public static function create( $initial = null )
	{
		if ($initial['class'] && is_subclass_of($initial['class'], get_called_class()))
			return $initial['class']::create($initial);
		return parent::create($initial);
	}

	/**
	* The SINGULAR CONSTRUCTOR for EXISTING instances
	* @param mixed $selector We accept the following selector formats:
	* 	- numeric id (must be used only with a specific class, ie. Element::get($id) is NOT allowed)
	*	- string handle in the format {class}={id} (if used with a specific class, the classes must match)
	*	- string where clause in SQL which will generate exactly one record; Specific only
	*	- array of traditional args such including "class" & "id", etc.; generic Element::get($args) is OK if $args[class] is valid; if the element is specific then $args[class] must match the class name
	* @returns Element A single object or NULL if the object was not found
	* @throws dbNotSingularX if the selector would produce more than one object of this class
	* @throws ErrorException if any of the parameter rules above are broken
	*/
	public static function get( $selector )
	{
		if (!$selector) // notably happens when receiving the result of a record load fresh from the database... not an error, just a negative.
			return null;

		$class = get_called_class();

		if ($selector instanceof $class)
			return $selector;

		if (is_array($selector)) {
			// the selector is an array of traditional args, notably "class", "where", and "id"
			if ($class == 'Element') {
				if (!isset($selector['class']) || !is_subclass_of($selector['class'], 'Element'))
					throw new ErrorException("Element::get( array {args} ) failed because there is no valid class within the args.");
			} else if ($selector['class'] && (!isset($selector['class']::$table) || !isset($class::$table) || $selector['class']::$table != $class::$table))
				throw new ErrorException("Element::get( array {args} ) failed because the requested class and called class aren't compatible (sharing the same DB table).");
			if ($selector['id'] < 1 && !$selector['where'])
				throw new ErrorException("Element::get( array {args} ): When passing loading args, get() needs at least an id or a where clause.");
			$q = $class::loadInstanceData($selector['id'], $selector);
			return $class::getInstanceFromLoadedData($q->next, $q->queryTime);
		}

		else if (is_numeric($selector)) {
			// When we receive a number, it's the id of a specific instance which we'll obtain
			if (!is_subclass_of($class, 'Element'))
				throw new ErrorException("Element::get( {numeric_id} ) is not allowed. You must use an instantiable subclass of Element.");
			$id = $selector * 1;
		}

		else if (is_string($selector)) {

			if (preg_match('/^([a-zA-Z_]*)=([0-9]*)$/', $selector, $m)) {
				// The selector is a handle in "{class}={id}" format
				if ($class == 'Element')
					$class = $m[1];
				else if ($m[1] != $class)
					throw new ErrorException("$class::get( {instance_handle} ) failed because the class in the handle does not match the called class.");
				$id = $m[2] * 1;

			} else {
				// When we receive any other string which is not a handle, we assume it's a WHERE clause for selecting a single instance from the database
				if ($class == 'Element')
					throw new ErrorException("Element::get( {where_clause} ) is not allowed. You must use an instantiable subclass of Element.");
				$q = $class::loadInstanceData(null, array('where'=>$selector));
				if ($q->rowCount > 1)
					throw new dbNotSingularX("Query Where clause produces more than one record.");
				if (!$q->rowCount)
					return null;
				return $class::getInstanceFromLoadedData($q->next, $q->queryTime);
			}
		}

		if (!$id)
			throw new ErrorException("No valid selector!");

		// Cache processing
		if (($obj = self::$cache[$x="$class=$id"]) instanceof Element)
			return $obj;

		$q = $class::loadInstanceData($id);
		if ($q->rowCount != 1)
			return logWarn("Failed to load $class=$id");

		return $class::getInstanceFromLoadedData($q->next, $q->queryTime);
	}

	/**
	* The PLURAL CONSTRUCTOR for EXISTING instances
	* @param array $args Associative array defines the parameters for loading the collection. The following optional parameters are relevant:
	*	- class = Not needed unless the class called is Element, in which case it must be a valid subclass of Element. If this is provided and the called class is specific, they must match.
	*	- id[] = An array of IDs is allowed
	*	- where = An SQL WHERE clause
	*	- sortfield = Name of a field to pull to the top of the sort relevance - sorting precedence and direction is defined in the data class
	*	- reverse = Boolean indication of whether to swap the sort order
	*	- limit = Number of records to stop at (regardless of where we start)
	*	- start = Ordinally first record to begin the result set
	*	- identifying - If true, we only load skeletons of the objects, ie. they will appear to the application as not loaded, but they will contain just enough data to be rendered as an identifiable element
	* @returns array An associative array of Element objects of the appropriate class. The indexes are the numeric IDs of the instances.
	*	Note: Unless there's an error (missing or bad focus or missing id/rel), we ALWAYS return an ARRAY of objects indexed by the element ID and ordered as requested, even if there's only 0 or 1 objects in it.
	* @throws ErrorException if any of the parameter rules above are broken
	*/
	public static function collection( array $args = array() )
	{
		$class = get_called_class();
		if ($class == 'Element' && (!$args['class'] || !$args['class'] instanceof Element || $args['class'] == 'Element'))
			throw new ErrorException("When called generically, a valid subclass of Element must be specified in the arguments ($args[class]).");
		if ($args['class'] && $args['class'] != $class)
			throw new ErrorException("An element class name was specified and it does not match the called class ($args[class]).");

		if ($args['id']) {
			if (!is_array($args['id']))
				throw new ErrorException("id can only be provided to this method in an array format.");
			if (!count($args['id']))
				return array();
		}

		$result = array();
		$q = $class::loadInstanceData($args['id'], $args);
		while ($record = $q->next) // the conditional assignment below allows getInstanceFromLoadedData to nix arriving records (as unauthorized, for example)
			if ($x = static::getInstanceFromLoadedData($record, $q->queryTime)) // assignment intended
				$result[$x->key] = $x;
		return $result;
	}

	/**
	* The render method provides the most feature-rich rendition of the element via it's identifying features only.
	* This means that not only is it in render-ready form as $this->_rendered would provide, but if the element has an authorized 'display' operation defined, it will be rendered as a link
	*	with an operation trigger to 'display' it.
	* @param HTMLRendering $R The HTMLRendering we're assembling into, providing authorization capability via its Context, getJSTrigger, among other things.
	* @return string An HTML-render-ready string which may include an active link to display this element in a subaction.
	*/
	public function render( HTMLRendering $R )
	{
		return $R->mode != $R::INPUT && $this->_stored && ($op = $this->getOperation('display', $R->context)) ?
			$R->renderOperationAsLink($op, $this->_rendered) : $this->_rendered;
	}

	/**
	* Obtains a simple associative array of HTML-rendered Elements indexed by their IDs, as in: array(3=>"Third Element Rendering", 15=>"Element the fifteenth!")
	* @param string (optional) $where SQL query where clause snippet to limit the results obtained.
	*	Use {} to represent this Element subclass's table and then specify joined tables by convention.
	*	Note that some system-level filtering may already be going on.
	* @param string $sortfield (optional) The name of the field to sort on primarily. Null is OK for standard sorting.
	* @param boolean $reverse (optional) Pass true to reverse the sort order.
	* @return string HTML-rendered option element list.
	*/
	public static function as_list( $where = null, $sortfield = null, $reverse = false )
	{
		$qargs = compact('sortfield','reverse');
		$qargs['where'] = str_replace('{}', static::$table, $where);
		$qargs['identifying'] = true;
		$result = array();
		foreach (static::collection($qargs) as $id=>$element)
			$result[$id] = $element->_rendered;
		return $result;
	}

	/**
	* Produces a rendered list of Elements in the format of 'option' html elements.
	* @param integer (optional) $selected If > 0 then 2 things happen:
	*		1) The Element with this ID is forced to be in the list, even if it would otherwise be filtered out.
	*		2) The option will be rendered as selected.
	*	You may have noticed that because we only accept a scalar here, we can't perform a multi-select rendering.
	* @param string (optional) $where SQL query where clause snippet to limit the results obtained.
	*	Use {} to represent this Element subclass's table and then specify joined tables by convention.
	*	Note that some system-level filtering may already be going on.
	* @param string $sortfield (optional) The name of the field to sort on primarily. Null is OK for standard sorting.
	* @param boolean $reverse (optional) Pass true to reverse the sort order.
	* @return string HTML-rendered option element list.
	*/
	public static function as_options( $selected = null, $where = null, $sortfield = null, $reverse = false )
	{
		if ($where && $selected)
			$where = "`{}`._id = $selected || $where";
		foreach (static::as_list($where, $sortfield, $reverse) as $id=>$rendered)
			$result .= "<option value=\"$id\"". ($id==$selected ? ' selected="1"' : null) .">$rendered</option>";
		return $result;
	}

	/**
	* We need to remove an element from our cache when it is deleted.
	*/
	public function delete( )
	{
		$myHandle = $this->_handle;
		parent::delete(); // assuming this succeeds without an exception...
		unset(self::$cache[$myHandle]); // remove the item from the cache... it can no longer be known by its old handle
	}

	/**
	* We're overriding the parent implementation in order to take care of setting the capcel sysval.
	* We ONLY do this during a CREATE (or possible future PROMOTE) operation.
	* @param Database $db The database interface. We'll use global $root if you don't provide one.
	* @return array The stored instance's key, even if nothing was written to the database.
	* @throws Exception if there is anything that prevents making sure the instance data is properly represented in the database
	*/
	protected function storeInstanceData( Database $db )
	{
		if ($this->key) // our special logic is ONLY for create situations, not update. Normal Instance store works for updates.
			return parent::storeInstanceData($db);

		$this->key = parent::storeInstanceData($db);
		$inctables = array($this::$table => "`{$this::$table}`._id = $this->key");
		$this->inctables($inctables);
		$db->dbQuery("UPDATE `". implode("`,`", array_keys($inctables)) ."` ".
				"SET `". implode("`._capcel='$this->_handle', `", array_keys($inctables)). "`._capcel='$this->_handle' ".
				"WHERE ". implode(" && ", array_values($inctables)) , "Set encapcelating handle");
		return $this->key;
	}

	/**
	* This function assembles an array with tablename=>$onclause for all objects in the included array.
	* This nifty little gadget may represent the wave of the future for dealing with full chains of included tables with one query.
	* Because a given table may only be included in a given object no more than once (because their field names are not allowed to collide),
	* It's entirely safe to do UPDATE through SET and WHERE with all the proper table chaining built in to the WHERE clause.
	* @param array $tablelist This gadget takes contributes to an accumulator array in which the keys are the simple names of tables to update and the values are chaining clauses
	* 	relating the include-type field values to the included table's _id. The values should be in fully SQL-ready format.
	* @return void This is all for recursive side-effect... building the array.
	*/
	protected function inctables( &$tablelist )
	{
		foreach ($this->included as $fn=>$inc) {
			if ($this::$fielddefs[$fn]['type'] != 'include')
				continue; // Fieldsets don't get this treatment.
			$tablelist[$inc::$table] = "`$this->_table`.`$fn`=`$inc->_table`._id";
			$inc->inctables($tablelist);
		}
	}

	public function formatField( $fn, $format = null )
	{
		if (($derived = $this->{¶.$fn}['derived']) == '{}._capcel') {
			if (!($handle = $this->capcel))
				return "( unstored )";
			list($class, $id) = explode('=', $handle, 2);
			return $class::$singular;
		} else if ($derived == '{}._id')
			return $this->key ? "$this->key" : "( unstored )";
		return parent::formatField($fn, $format);
	}

	public function renderField( $fn, HTMLRendering $R, $format = null )
	{
		$fd = $this->{¶.$fn};
		if (in_array($fd['derived'], [ '{}._id' , '{}._capcel' ] ))
			$result = "<span id=\"$R->idprefix$fn\">". $this->formatField($fn) ."</span>";
		else
			$result = parent::renderField($fn, $R, $format);
		return $R->mode != $R::INPUT && $this->_stored && $fd['identifying'] && $R->focus != $this && ($op = $this->getOperation('display', $R->context)) ?
			$R->renderOperationAsLink($op, $result ? $result : '&nbsp;') : $result;
	}

	public function getFieldValue( $fn )
	{
		return ($derived = $this->{¶.$fn}['derived']) == '{}._id' ? $this->key : ($derived == '{}._capcel' ? Element::get($this->_capcel) : parent::getFieldValue($fn, $R, $format));
	}

	/**
	* As an Element you can get the metaproperties _id (simple numeric key), _handle (system-unique instance identifier), _formatted (string form of a field), _rendered (HTML-compatible string form of a field)
	* Developers: If you override this __get() method in a subclass BE SURE TO RETURN BY REFERENCE because arrays of modifiable values may be returned for some types.
	*	Also be sure to pass thru to the parent's magic __get method if you fail to satisfy the request.
	*/
	public function getMetaProperty( $name )
	{
		switch ($name) {
			case 'cacheHash':
			case 'handle':   		return get_class($this) ."=$this->key";
			case 'formatted':	return $this->formatted();
			case 'rendered':		return htmlentities($this->formatted());
			case 'stored':     	return $this->key && true;
			case 'capcel':      	return $this->capcel;
		}
		return parent::getMetaProperty($name);
	}

	/**
	* We have an ugly default way to format an element, but we prefer to return the rendering loaded from the database or otherwise established by code.
	*/
	public function formatted()
	{
		return $this->formatted ? $this->formatted : "$this->_singular ". ($this->key ? "#$this->key" : "(new)");
	}

	/**
	* When you use an element as a string you will get its formatted name
	*/
	public function __toString()
	{
		return $this->formatted();
	}

	/**
	* We implement caching for elements, so we override this method.
	*/
	protected static function getInstanceFromLoadedData( array $record = null, $time = null, $prefix = "" )
	{
		if (!$record)
			return null;
		$class = get_called_class();
		list($subClass, $id) = explode('=', $record['_capcel'], 2);
		if ($subClass && $class && $class != $subClass && $subClass::$table == $class::$table)
			$class = $subClass;
		if ($class == 'Element')
			throw new ErrorException("Only a specific element class can be gotten from a data record.");
		// We either grab the object from the cache or create it; then populate it with the data we're passed.
		// No additional loading is required here, so we can return immediately
		$handle = "$class={$record[$prefix.'_id']}";
		if (!($obj = self::$cache[$handle]))
			$obj = new $class;
		// We allow constructing an existing object without its full data to prevent going to the database for no reason... it will load on demand if ever needed.
		// Typically this happens here when only _id and _formatted are set.
		// Note that we won't backlevel a loaded object, although that's pretty unlikely, but we also get performance savings by not re-interpreting full repeating instance data from the same query (as with relatives, etc.)
		if (!array_key_exists('_loadtime', $obj->loaded) || (array_key_exists("{$prefix}_loadtime", $record) && $obj->loaded['_loadtime'] < $record["{$prefix}_loadtime"]))
			if (!$obj->acceptInstanceData($record, $time, $prefix))
				return null;
		self::$cache[$handle] = $obj;
		return $obj;
	}

	/**
	* Call this function to get a list of all the classes which are ultimate AND include existing instances of this element class.
	* This will NOT include intermediate element classes unless they also happen to appear as ultimate elsewhere.
	* We do not filter or sort the result in any way, we just let you know quickly which including classes there are.
	* This approach to processing and returning the answer makes for rapid use of the class name to quickly load a collection of the right class.
	* @return string[] Returns list of class names. The list may be empty but it will still be an array.
	*/
	public static function getUltimateClasses( )
	{
		$cc = get_called_class();
		$table = $cc::$table;
		$list = $GLOBALS['root']->dbGetScalar("SELECT GROUP_CONCAT(DISTINCT SUBSTRING(_capcel,1,LOCATE('=',_capcel)-1)) FROM `$table`", __FUNCTION__);
		return $list ? explode(',', $list) : array();
	}

	/**
	* We override duplicate to handle the _capcel field
	*/
	public function duplicate( )
	{
		$dupe = parent::duplicate();
		$dupe->capcel = null; // This will get set appropriately when it is first stored.
		return $dupe;
	}

	/**
	* Gets you a JSON representation of an Element.
	* Element objects are provided as numeric IDs.
	* If the value is a string, we'll put it in quotes.
	* If the value is boolean, we'll return it as true or false.
	* If it's numeric, it will come across as numeric.
	* Otherwise it will come across null.
	* @param mixed $parms (optional) If you pass a Context, we'll extract the $c->request['args']['include'] and 'exclude' to pass to getFieldDefs().
	*		If you pass an array, we'll assume it's a list of the fields you want included ('include'). If not provided, all fields are included.
	* @return string JSON representation of this Element instance.
	*/
	public function asJSON( $parms = null )
	{
		// parameter processing
		if ($parms instanceof Context) {
			$c = $parms;
			extract(array_intersect_key($parms->request['args'], ['include'=>1, 'exclude'=>1]));
		} else if (is_array($parms))
			$include = $parms;

		// assembling the response
		foreach ($this::getFieldDefs($c, $exclude, $include) as $fn=>$fd) {
			if (($value = $this->$fn) instanceof Element)
				$rendVal = $value->_id;
			else if (is_numeric($value))
				$rendVal = $value * 1;
			else if (is_string($value))
				$rendVal = "\"$value\"";
			else if (is_bool($value))
				$rendVal = $value ? 'true' : 'false';
			else
				$rendVal = 'null';
			$pairs[] = "\"$fn\":$rendVal";
		}
		return "{ ". implode(', ', $pairs) ." }";
	}

	/**
	* Call this to get a rendering of a collection of Elements' "flat" field values in JSON format.
	* @param string $filter Query snippet filtering the collection.
	* @param integer|integer[]|Element|Element[] $selected (optional) If there's a filter, any Elements identified by this parameter will pass filtering regardless.
	*		Elements provided here must use the same database table as this class.
	* @param boolean $indexed (true assumed) If true, then we return a wrapper object and the Element IDs are the keys to the Elements included.
	*		If false, we return a JSON array (list) of Elements. In both cases the Elements themselves are returned as JSON objects.
	* @param string[] $fields (optional) You can pass a list of the fields you want included. If not provided, all fields are included.
	* @return string[] Returns an array of JSON strings, each of which is an Object with field names as the keys with flat / formatted values.
	*/
	public static function getElementsAsJson( $filter = null, $selected = null, $indexed = true, array $fields = null )
	{
		$open = $indexed ? '{' : '[';
		$close = $indexed ? '}' : ']';
		if ($filter && $selected) {
			foreach ((array)$selected as $x)
				if ($x > 0 || ($x instanceof Element && $x::$table == static::$table))
					$sel[] = is_scalar($x) ? $x * 1 : $x->_id;
			if (count($sel))
				$filter = "{}._id IN (". implode(',',$sel) .") || ($filter)";
		}
		foreach (static::collection(array('where'=>$filter)) as $x)
			$elements[] = $indexed ? "$x->_id:".$x->asJSON($fields) : $x->asJSON($fields);
		return "$open\n     ". implode("\n    ,", $elements) ."\n$close";
	}
}
